# Creating a Rhino plug-in

Introduction into writing a Rhino plug-in. For this plug-in we are going to use
Visual Studio Code and dotnet tools.

## Creating the project

Since the plug-in is essentially a DLL, with the extension renamed to RHP, we
create a classlib template project.

``` PS
PS> dotnet new classlib
```

To have the generated project compile as a Rhino plug-in, we need to make some
changes to the project file. Rhino 7 targets itself .NET 4.8 framework, so we
are going to do the same.

This also means that we need to disable the C# 10 features.

We also need to tell the project that we want an RHP file, not a DLL. For this
we are going to use the `<TargetExt>` tag.

``` xml
<TargetExt>.rhp</TargetExt>
```

We also want to control the project management manually. This means we need to
disable default items, as well as disable automatic assembly information
generation. This can be done with the tags `<EnableDefaultItems>` and
`<GenerateAssemblyInfo>`.

``` xml
<EnableDefaultItems>False</EnableDefaultItems>
<GenerateAssemblyInfo>False</GenerateAssemblyInfo>
```

To be able to use RhinoCommon SDK we need to add the RhinoCommon package
reference from NuGet. The current version we are going to use is
7.12.21313.6341.

## Creating the plug-in class

A Rhino plug-in derives from one of the plug-in classes that is provided by the
`Rhino.PlugIns` namespace. There are several available, for import, export, and
so. But our case we are going to do just a simple utility plug-in. Such plug-in
derives from `Rhino.PlugIns.PlugIn`.

``` csharp : <<jesterLiveCode plug-in.*>>= ./jesterLiveCode/jesterLiveCodePlugin.cs
using Rhino;
using Rhino.PlugIns;

namespace jesterLiveCode {

    public class jesterLiveCodePlugin : PlugIn
    {
        <<jesterLiveCode plug-in construction>>
    }
}
```

Rhino plug-ins are going to be initialized by Rhino, and for plug-ins there
should always be only one instance. So a singleton pattern here is going to be
needed.

``` csharp : <<jesterLiveCode plug-in construction>>=
public jesterLiveCodePlugin()
{
    if(Instance == null)
    {
        Instance = this;
    }
}

public static jesterLiveCodePlugin Instance { get; private set; }
```

## Setting up the assembly information

For to be able to load the plug-in properly the correct assembly attributes need
to be present. The `PlugInDescription` attribute needs to be set with several
different types. Also the assembly needs to have a unique GUID. And finally
there needs to be file versioning.

``` csharp : <<jesterLiveCode assembly info.*>>= ./jesterLiveCode/Properties/AssemblyInfo.cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Rhino.PlugIns;
[assembly: PlugInDescription(DescriptionType.Address, "Turku")]
[assembly: PlugInDescription(DescriptionType.Country, "Finland")]
[assembly: PlugInDescription(DescriptionType.Email, "jesterking@letwory.net")]
[assembly: PlugInDescription(DescriptionType.Phone, "-")]
[assembly: PlugInDescription(DescriptionType.Fax, "-")]
[assembly: PlugInDescription(DescriptionType.Organization, "Letwory Interactive Oy")]
[assembly: PlugInDescription(DescriptionType.UpdateUrl, "-")]
[assembly: PlugInDescription(DescriptionType.WebSite, "https://www.letworyinteractive.com")]


[assembly: AssemblyTitle("jesterLiveCode")] // Plug-In title is extracted from this
[assembly: AssemblyDescription("A plug-in showing the ropes of writing code for Rhino.")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Letwory Interactive Oy")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("Copyright Â©  2021")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("0fda72f0-ccd3-4b75-8896-f495ae82fc18")]
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("0.0.1.0")]
[assembly: AssemblyFileVersion("0.0.1.0")]
```

## Creating a command

A command in Rhino derives from `Rhino.Commands.Command`. There two mandatory
parts for a command to implement to get a minimal implementation.

For this command we are going to start a fragment where we are going to collect
all the namespace usages.

We need at least the `Rhino.Commands` namespace. And lets also bring in `Rhino`,
since that is where `RhinoDoc` lives.

``` csharp : <<first command usings>>=
using Rhino;
using Rhino.Commands;
```

Our command class is going to be called `jesterBoxCommand`, which will generate
a custom object (TBD) that can be eventually controlled via a custom panel.
While our command is active we'll be drawing temporary results with the dislay
conduit called `jesterBoxConduit`.

Apart from the necessary command overrides there will be some utilities
implementated in this class that can be used for creating and visualizing our
object. These will be provided in `<<jesterBox command utilities>>`.

``` csharp : <<first command class.*>>= ./jesterLiveCode/jesterBoxCommand.cs
<<first command usings>>

namespace jesterLiveCode
{
    public class jesterBoxCommand: Command
    {
        <<first command overrides>>
        <<jesterBox command utilities>>
    }
}
```

### The mandatory overrides for a Command class

To get a minimal working `Command` the property `EnglishName`. This property
will essentially be the name of the command as you type it into the Rhino
command-line.

``` csharp : <<first command overrides>>=
public override string EnglishName => "jesterBox";
```

We also need to override the method `RunCommand`, which is going to be the
actual meat of the command. Here the driving logic of the command will live. We
want to add an object, a box actually, with given dimensions to a place where
the user has picked a point.

#### RunCommand implementation

The main structure looks a bit like this:


``` csharp : <<first command overrides>>=+
protected override Result RunCommand(RhinoDoc doc, RunMode mode)
{
    <<add command options>>
    <<get point>>
    <<set up jesterBox display conduit>>
    <<handle get loop>>
    <<add the object>>
    return Result.Success;
}
```

##### Command options

First we need to add the command options. In our case we are going to use just
simple integer options for the dimensions of the box. To be able to use the
custom input classes we need to ensure we have the proper namespace added. The
Rhino `Get` classes return also a `GetResult`, which is provided by the
`Rhino.Input` namespace.

``` csharp : <<first command usings>>=+
using Rhino.Input;
using Rhino.Input.Custom;
```

Now we are able to use all classes provided by the namespace `Rhino.Input.Custom`.

``` csharp : <<add command options>>=
int width = 10;
int length = 10;
int height = 10;

OptionInteger widthOption = new OptionInteger(width, 1, 50);
OptionInteger lengthOption = new OptionInteger(length, 1, 50);
OptionInteger heightOption = new OptionInteger(height, 1, 50);
```

##### GetPoint instance

As mention we want to add the box to a user picked position. For that we need
the `GetPoint` class. And we can add the options to the instance of that class
when we have one. It is also good to tell the user what is expected from them,
so lets set the command-prompt to "Select a location". The user is supposed to
press `Enter` when they are happy with the given settings. To this end we need
to ensure that our `GetPoint` instance actually can accept nothing.

``` csharp : <<get point>>=
Point3d point = Point3d.Origin;
GetPoint getPoint = new GetPoint();
getPoint.AcceptNothing(true);
getPoint.SetCommandPrompt("Pick a location, and enter when done");
getPoint.AddOptionInteger("Width", ref widthOption);
getPoint.AddOptionInteger("Length", ref lengthOption);
getPoint.AddOptionInteger("Height", ref heightOption);
```

Since we are getting a `Point3d` instance we need to ensure that we have the
`Rhino.Geometry` namespace available to us.

``` csharp : <<first command usings>>=+
using Rhino.Geometry;
using System.Collections.Generic;
```

##### Initialize the display conduit

To visualize the user input we need our `jesterBoxConduit`. We need to
give it all the information it needs to draw properly. First however we need to
initialize an instance that we can use.

``` csharp : <<set up jesterBox display conduit>>=
jesterBoxConduit conduit = new jesterBoxConduit();

conduit.Location = point;
conduit.Width = width;
conduit.Height = height;
conduit.Length = length;

conduit.Enabled = true;
```


##### Input loop handling

Now we can start handling the get loop. The loop will be essentially an eternal
loop with proper exit conditions sprinkled throughout the loop.

Each time an option is changed, or a point is clicked we need to update the
conduit as well to ensure proper visualization of the current settings.

``` csharp : <<handle get loop>>=
for(;;)
{
    GetResult result = getPoint.Get();

    if(result == GetResult.Point)
    {
        point = getPoint.Point();
        conduit.Location = point;
        RhinoApp.WriteLine($"User clicked point {point}");
        continue;
    }

    if(result == GetResult.Option)
    {
        width = widthOption.CurrentValue;
        length = lengthOption.CurrentValue;
        height = heightOption.CurrentValue;

        conduit.Width = width;
        conduit.Height = height;
        conduit.Length = length;

        RhinoApp.WriteLine($"Current given dimensions {width}x{length}x{height}");
        continue;
    }

    if(result == GetResult.Nothing)
    {
        break;
    }

    if(result == GetResult.Cancel)
    {
        conduit.Enabled = false;
        RhinoApp.WriteLine("Command cancelled");
        return Result.Cancel;
    }
}
```

##### Adding the object

Once we get out of the loop and are still in the command we can add the object
to the specifications given by the user on the command-line.

To add the object we use the `CreateJesterBox` method provided by `<<jesterBox
command utilities>>`.

We also disable our conduit, so it doesn't get called all the time for nothing.

``` csharp : <<add the object>>=
conduit.Enabled = false;
Brep boxBrep = CreateJesterBox(point, width, height, length);
doc.Objects.AddBrep(boxBrep);
doc.Views.Redraw();
```

``` csharp : <<jesterBox command utilities>>=
static public Brep CreateJesterBox(Point3d point, int width, int height, int length)
{
    Plane p = new Plane(point, Vector3d.ZAxis);
    Interval widthInterval = new Interval(0, width);
    Interval lengthInterval = new Interval(0, length);
    Interval heightInterval = new Interval(0, height);
    Box box = new Box(p, widthInterval, lengthInterval, heightInterval);
    Brep boxBrep = box.ToBrep();

    if(boxBrep == null)
    {
        System.Diagnostics.Debug.WriteLine("Our brep is not good :/");
        System.Diagnostics.Debug.WriteLine($"{point}, {width}x{height}x{length}");
        System.Diagnostics.Debug.WriteLine($"...");
    }

    return boxBrep;
}
```

## Creating a DisplayConduit

To be able to show intermediate results of our command while it is still running
we can use a `DisplayConduit`. This will allow us to draw results without having
to actually add geometry to the document.

To implement the `DisplayConduit` we need to inherit
`Rhino.Display.DisplayConduit`, and at least implement calculation of scene
bounding box and a draw method. For our command and display conduit we are going
to draw in `DrawOverlay`. We also want to be able to pass on the data to be
visualized, which we'll do with `<<jesterBoxConduit data access>>`.

``` csharp : <<jesterBox display conduit.*>>= ./jesterLiveCode/jesterBoxConduit.cs
<<jesterBox usings>>

namespace jesterLiveCode {
    public class jesterBoxConduit : DisplayConduit
    {
        <<jesterBoxConduit data access>>
        <<jesterBoxConduit calculate bounding box>>
        <<jesterBoxConduit draw overlay>>
    }
}
```

We must not forget to add the proper namespace so we can use it in our class
implementation:

``` csharp : <<jesterBox usings>>=
using Rhino.Display;
```

### Data access

The display conduit implementation will provide several properties to set and
read the information we want to visualize. This will be for the location, width,
height and length of our object.

``` csharp : <<jesterBoxConduit data access>>=
public Point3d Location { get; set; }
public int Width { get; set; }
public int Height { get; set; }
public int Length { get; set; }
```

Since we need `Point3d` we also need to bring in the `Rhino.Geometry` namespace.

``` csharp : <<jesterBox usings>>=+
using Rhino.Geometry;
```

### Calculating the bounding box

To be able to properly draw our geometry we need to tell the display pipeline
what the bounding box is for our geometry. Without the proper bounding box
geometry will easily get clipped.

``` csharp : <<jesterBoxConduit calculate bounding box>>=
protected override void CalculateBoundingBox(CalculateBoundingBoxEventArgs bbe)
{
    base.CalculateBoundingBox(bbe);
    Brep box = jesterBoxCommand.CreateJesterBox(Location, Width, Height, Length);
    BoundingBox bb = box.GetBoundingBox(false);

    bbe.IncludeBoundingBox(bb);
}
```

### Drawing the temporary geometry

``` csharp : <<jesterBoxConduit draw overlay>>=
protected override void DrawOverlay(DrawEventArgs drawe)
{
    base.DrawOverlay(drawe);
    Brep box = jesterBoxCommand.CreateJesterBox(Location, Width, Height, Length);
    drawe.Display.DrawBrepWires(box, System.Drawing.Color.Blue);
}
```