<html>
	<head>
		<link rel="stylesheet" type="text/css" href="./style.css">
	</head>
	<body>
	<h1>Creating a Rhino plug-in</h1>
<p>Introduction into writing a Rhino plug-in. For this plug-in we are going to use
Visual Studio Code and dotnet tools.</p>
<h2>Setting up the project</h2>
<p>Since the plug-in is essentially a DLL, with the extension renamed to RHP, we
create a .csproj file that contains the project description. We are going to add
all necessary information to the rrespective fragments.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;jesterLiveCode project file.*&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-tag">&lt;<span class="hljs-name">Project</span> <span class="hljs-attr">Sdk</span>=<span class="hljs-string">&quot;Microsoft.NET.Sdk&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
		&lt;<span class="hljs-tag">&lt;<span class="hljs-name">jesterLiveCode</span> <span class="hljs-attr">project</span> <span class="hljs-attr">properties</span>&gt;</span>&gt;
	<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
		&lt;<span class="hljs-tag">&lt;<span class="hljs-name">jesterLiveCode</span> <span class="hljs-attr">project</span> <span class="hljs-attr">package</span> <span class="hljs-attr">references</span>&gt;</span>&gt;
	<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
		&lt;<span class="hljs-tag">&lt;<span class="hljs-name">jesterLiveCode</span> <span class="hljs-attr">source</span> <span class="hljs-attr">files</span>&gt;</span>&gt;
	<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Project</span>&gt;</span>
</code></pre>
</div></div><p>To have the project compile as a Rhino plug-in, we need to target the .NET 4.8 framework.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;jesterLiveCode project properties&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-tag">&lt;<span class="hljs-name">TargetFramework</span>&gt;</span>net48<span class="hljs-tag">&lt;/<span class="hljs-name">TargetFramework</span>&gt;</span>
</code></pre>
</div></div><p>We also need to tell the project that we want an RHP file, not a DLL. For this
we are going to use the <code>&lt;TargetExt&gt;</code> tag.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;jesterLiveCode project properties&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-tag">&lt;<span class="hljs-name">TargetExt</span>&gt;</span>.rhp<span class="hljs-tag">&lt;/<span class="hljs-name">TargetExt</span>&gt;</span>
</code></pre>
</div></div><p>We also want to control the project management manually. This means we need to
disable default items, as well as disable automatic assembly information
generation. This can be done with the tags <code>&lt;EnableDefaultItems&gt;</code> and
<code>&lt;GenerateAssemblyInfo&gt;</code>.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;jesterLiveCode project properties&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-tag">&lt;<span class="hljs-name">EnableDefaultItems</span>&gt;</span>False<span class="hljs-tag">&lt;/<span class="hljs-name">EnableDefaultItems</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">GenerateAssemblyInfo</span>&gt;</span>False<span class="hljs-tag">&lt;/<span class="hljs-name">GenerateAssemblyInfo</span>&gt;</span>
</code></pre>
</div></div><p>To be able to use RhinoCommon SDK we need to add the RhinoCommon package
reference from NuGet. The current version we are going to use is
7.12.21313.6341.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;jesterLiveCode project package references&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-tag">&lt;<span class="hljs-name">PackageReference</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">&quot;RhinoCommon&quot;</span> <span class="hljs-attr">Version</span>=<span class="hljs-string">&quot;7.12.21313.6341&quot;</span>/&gt;</span>
</code></pre>
</div></div><p>To be able to debug using the Windows PDB format, this needs to be configured in
the project settings. We want to use the <code>full</code> format for PDB files, not the
<code>portable</code> format. Furthermore we want to enable debug symbols at all times.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;jesterLiveCode project properties&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-tag">&lt;<span class="hljs-name">DebugType</span>&gt;</span>full<span class="hljs-tag">&lt;/<span class="hljs-name">DebugType</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">DebugSymbols</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">DebugSymbols</span>&gt;</span>
</code></pre>
</div></div><h2>Creating the plug-in class</h2>
<p>A Rhino plug-in derives from one of the plug-in classes that is provided by the
<code>Rhino.PlugIns</code> namespace. There are several available, for import, export, and
so. But our case we are going to do just a simple utility plug-in. Such plug-in
derives from <code>Rhino.PlugIns.PlugIn</code>.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;jesterLiveCode plug-in.*&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">using</span> Rhino;
<span class="hljs-keyword">using</span> Rhino.PlugIns;

<span class="hljs-keyword">namespace</span> <span class="hljs-title">jesterLiveCode</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">jesterLiveCodePlugin</span> : <span class="hljs-title">PlugIn</span>
    {
        &lt;&lt;jesterLiveCode plug-<span class="hljs-keyword">in</span> construction&gt;&gt;
    }
}
</code></pre>
</div></div><p>The source file needs to be added to the project to have it compiled, since we
are managing the project manually.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;jesterLiveCode source files&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-tag">&lt;<span class="hljs-name">Compile</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">&quot;jesterLiveCodePlugin.cs&quot;</span> /&gt;</span>
</code></pre>
</div></div><p>Rhino plug-ins are going to be initialized by Rhino, and for plug-ins there
should always be only one instance. So a singleton pattern here is going to be
needed.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;jesterLiveCode plug-in construction&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">jesterLiveCodePlugin</span>(<span class="hljs-params"></span>)</span>
{
    <span class="hljs-keyword">if</span>(Instance == <span class="hljs-literal">null</span>)
    {
        Instance = <span class="hljs-keyword">this</span>;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> jesterLiveCodePlugin Instance { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }
</code></pre>
</div></div><h2>Setting up the assembly information</h2>
<p>For to be able to load the plug-in properly the correct assembly attributes need
to be present. The <code>PlugInDescription</code> attribute needs to be set with several
different types. Also the assembly needs to have a unique GUID. And finally
there needs to be file versioning.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;jesterLiveCode assembly info.*&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">using</span> System.Reflection;
<span class="hljs-keyword">using</span> System.Runtime.CompilerServices;
<span class="hljs-keyword">using</span> System.Runtime.InteropServices;
<span class="hljs-keyword">using</span> Rhino.PlugIns;
[<span class="hljs-meta">assembly: PlugInDescription(DescriptionType.Address, <span class="hljs-string">&quot;Turku&quot;</span>)</span>]
[<span class="hljs-meta">assembly: PlugInDescription(DescriptionType.Country, <span class="hljs-string">&quot;Finland&quot;</span>)</span>]
[<span class="hljs-meta">assembly: PlugInDescription(DescriptionType.Email, <span class="hljs-string">&quot;jesterking@letwory.net&quot;</span>)</span>]
[<span class="hljs-meta">assembly: PlugInDescription(DescriptionType.Phone, <span class="hljs-string">&quot;-&quot;</span>)</span>]
[<span class="hljs-meta">assembly: PlugInDescription(DescriptionType.Fax, <span class="hljs-string">&quot;-&quot;</span>)</span>]
[<span class="hljs-meta">assembly: PlugInDescription(DescriptionType.Organization, <span class="hljs-string">&quot;Letwory Interactive Oy&quot;</span>)</span>]
[<span class="hljs-meta">assembly: PlugInDescription(DescriptionType.UpdateUrl, <span class="hljs-string">&quot;-&quot;</span>)</span>]
[<span class="hljs-meta">assembly: PlugInDescription(DescriptionType.WebSite, <span class="hljs-string">&quot;https://www.letworyinteractive.com&quot;</span>)</span>]


[<span class="hljs-meta">assembly: AssemblyTitle(<span class="hljs-string">&quot;jesterLiveCode&quot;</span>)</span>] <span class="hljs-comment">// Plug-In title is extracted from this</span>
[<span class="hljs-meta">assembly: AssemblyDescription(<span class="hljs-string">&quot;A plug-in showing the ropes of writing code for Rhino.&quot;</span>)</span>]
[<span class="hljs-meta">assembly: AssemblyConfiguration(<span class="hljs-string">&quot;&quot;</span>)</span>]
[<span class="hljs-meta">assembly: AssemblyCompany(<span class="hljs-string">&quot;Letwory Interactive Oy&quot;</span>)</span>]
[<span class="hljs-meta">assembly: AssemblyProduct(<span class="hljs-string">&quot;&quot;</span>)</span>]
[<span class="hljs-meta">assembly: AssemblyCopyright(<span class="hljs-string">&quot;Copyright ©  2021&quot;</span>)</span>]
[<span class="hljs-meta">assembly: AssemblyTrademark(<span class="hljs-string">&quot;&quot;</span>)</span>]
[<span class="hljs-meta">assembly: AssemblyCulture(<span class="hljs-string">&quot;&quot;</span>)</span>]

<span class="hljs-comment">// Setting ComVisible to false makes the types in this assembly not visible</span>
<span class="hljs-comment">// to COM components.  If you need to access a type in this assembly from</span>
<span class="hljs-comment">// COM, set the ComVisible attribute to true on that type.</span>
[<span class="hljs-meta">assembly: ComVisible(false)</span>]

<span class="hljs-comment">// The following GUID is for the ID of the typelib if this project is exposed to COM</span>
[<span class="hljs-meta">assembly: Guid(<span class="hljs-string">&quot;0fda72f0-ccd3-4b75-8896-f495ae82fc18&quot;</span>)</span>]
<span class="hljs-comment">// Version information for an assembly consists of the following four values:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//      Major Version</span>
<span class="hljs-comment">//      Minor Version</span>
<span class="hljs-comment">//      Build Number</span>
<span class="hljs-comment">//      Revision</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// You can specify all the values or you can default the Build and Revision Numbers</span>
<span class="hljs-comment">// by using the &#x27;*&#x27; as shown below:</span>
<span class="hljs-comment">// [assembly: AssemblyVersion(&quot;1.0.*&quot;)]</span>
[<span class="hljs-meta">assembly: AssemblyVersion(<span class="hljs-string">&quot;0.0.1.0&quot;</span>)</span>]
[<span class="hljs-meta">assembly: AssemblyFileVersion(<span class="hljs-string">&quot;0.0.1.0&quot;</span>)</span>]
</code></pre>
</div></div><p>Add the assembly information file to the project</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;jesterLiveCode source files&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-tag">&lt;<span class="hljs-name">Compile</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">&quot;Properties/AssemblyInfo.cs&quot;</span> /&gt;</span>
</code></pre>
</div></div><h2>Creating a command</h2>
<p>A command in Rhino derives from <code>Rhino.Commands.Command</code>. There two mandatory
parts for a command to implement to get a minimal implementation.</p>
<p>For this command we are going to start a fragment where we are going to collect
all the namespace usages.</p>
<p>We need at least the <code>Rhino.Commands</code> namespace. And lets also bring in <code>Rhino</code>,
since that is where <code>RhinoDoc</code> lives.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;first command usings&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">using</span> Rhino;
<span class="hljs-keyword">using</span> Rhino.Commands;
</code></pre>
</div></div><p>Our command class is going to be called <code>jesterBoxCommand</code>, which will generate
a custom object (TBD) that can be eventually controlled via a custom panel.
While our command is active we'll be drawing temporary results with the dislay
conduit called <code>jesterBoxConduit</code>.</p>
<p>Apart from the necessary command overrides there will be some utilities
implementated in this class that can be used for creating and visualizing our
object. These will be provided in <code>&lt;&lt;jesterBox command utilities&gt;&gt;</code>.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;jesterLiveCode source files&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-tag">&lt;<span class="hljs-name">Compile</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">&quot;jesterBoxCommand.cs&quot;</span> /&gt;</span>
</code></pre>
</div></div><div class="codefragment"><div class="fragmentname">&lt;&lt;first command class.*&gt;&gt;=</div><div class="code"><pre><code>&lt;&lt;first command usings&gt;&gt;

<span class="hljs-keyword">namespace</span> <span class="hljs-title">jesterLiveCode</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">jesterBoxCommand</span>: <span class="hljs-title">Command</span>
    {
        &lt;&lt;first command overrides&gt;&gt;
        &lt;&lt;jesterBox command utilities&gt;&gt;
    }
}
</code></pre>
</div></div><h3>The mandatory overrides for a Command class</h3>
<p>To get a minimal working <code>Command</code> the property <code>EnglishName</code>. This property
will essentially be the name of the command as you type it into the Rhino
command-line.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;first command overrides&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> EnglishName =&gt; <span class="hljs-string">&quot;jesterBox&quot;</span>;
</code></pre>
</div></div><p>We also want to try localize our plug-in. To that end we need to override the
<code>LocalName</code> property. Note that we do need access to the <code>Localization</code> class of
the <code>Rhino.UI</code> namespace.</p>
<p>We need the assembly object our plug-in to pass on to the localization system.
For this we also need access to the <code>System.Reflection</code> assembly.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;first command overrides&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> LocalName {
    <span class="hljs-keyword">get</span> {
        Assembly ass = Assembly.GetExecutingAssembly();
        <span class="hljs-keyword">return</span> Localization.LocalizeString(<span class="hljs-string">&quot;jesterBox&quot;</span>, ass, <span class="hljs-number">1</span>);
    }
}
</code></pre>
</div></div><div class="codefragment"><div class="fragmentname">&lt;&lt;first command usings&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-keyword">using</span> System.Reflection;
</code></pre>
</div></div><div class="codefragment"><div class="fragmentname">&lt;&lt;first command usings&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-keyword">using</span> Rhino.UI;
</code></pre>
</div></div><p>We also need to override the method <code>RunCommand</code>, which is going to be the
actual meat of the command. Here the driving logic of the command will live. We
want to add an object, a box actually, with given dimensions to a place where
the user has picked a point.</p>
<h4>RunCommand implementation</h4>
<p>The main structure looks a bit like this:</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;first command overrides&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Result <span class="hljs-title">RunCommand</span>(<span class="hljs-params">RhinoDoc doc, RunMode mode</span>)</span>
{
    &lt;&lt;<span class="hljs-keyword">add</span> command options&gt;&gt;
    &lt;&lt;<span class="hljs-keyword">set</span> up jesterBox display conduit&gt;&gt;
    &lt;&lt;<span class="hljs-keyword">get</span> point&gt;&gt;
    &lt;&lt;handle <span class="hljs-keyword">get</span> loop&gt;&gt;
    &lt;&lt;<span class="hljs-keyword">add</span> the <span class="hljs-built_in">object</span>&gt;&gt;
    <span class="hljs-keyword">return</span> Result.Success;
}
</code></pre>
</div></div><h5>Command options</h5>
<p>First we need to add the command options. In our case we are going to use just
simple integer options for the dimensions of the box. To be able to use the
custom input classes we need to ensure we have the proper namespace added. The
Rhino <code>Get</code> classes return also a <code>GetResult</code>, which is provided by the
<code>Rhino.Input</code> namespace.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;first command usings&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-keyword">using</span> Rhino.Input;
<span class="hljs-keyword">using</span> Rhino.Input.Custom;
</code></pre>
</div></div><p>Now we are able to use all classes provided by the namespace <code>Rhino.Input.Custom</code>.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;add command options&gt;&gt;=</div><div class="code"><pre><code>Point3d point = Point3d.Unset;
<span class="hljs-built_in">int</span> width = <span class="hljs-number">10</span>;
<span class="hljs-built_in">int</span> length = <span class="hljs-number">10</span>;
<span class="hljs-built_in">int</span> height = <span class="hljs-number">10</span>;

OptionInteger widthOption = <span class="hljs-keyword">new</span> OptionInteger(width, <span class="hljs-number">1</span>, <span class="hljs-number">50</span>);
OptionInteger lengthOption = <span class="hljs-keyword">new</span> OptionInteger(length, <span class="hljs-number">1</span>, <span class="hljs-number">50</span>);
OptionInteger heightOption = <span class="hljs-keyword">new</span> OptionInteger(height, <span class="hljs-number">1</span>, <span class="hljs-number">50</span>);
</code></pre>
</div></div><h5>GetPoint instance</h5>
<p>As mention we want to add the box to a user picked position. For that we need
the <code>GetPoint</code> class. For our project we implement a custom <code>GetPoint</code> class,
<code>jesterBoxGetPoint</code>, which we will be using to handle interactive mouse
movements and display some intermediate results while our command is still
active. And we can add the options to the instance of that class when we have
one. It is also good to tell the user what is expected from them, so lets set
the command-prompt to &quot;Select a location&quot;. The user is supposed to press <code>Enter</code>
when they are happy with the given settings. To this end we need to ensure that
our <code>jesterBoxGetPoint</code> instance actually can accept nothing.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;get point&gt;&gt;=</div><div class="code"><pre><code>jesterBoxGetPoint getPoint = <span class="hljs-keyword">new</span> jesterBoxGetPoint(conduit);
point = conduit.Location = conduit.PotentialLocation;
getPoint.AcceptNothing(<span class="hljs-literal">true</span>);
getPoint.SetCommandPrompt(<span class="hljs-string">&quot;Pick a location, and enter when done&quot;</span>);
getPoint.AddOptionInteger(<span class="hljs-string">&quot;Width&quot;</span>, <span class="hljs-keyword">ref</span> widthOption);
getPoint.AddOptionInteger(<span class="hljs-string">&quot;Length&quot;</span>, <span class="hljs-keyword">ref</span> lengthOption);
getPoint.AddOptionInteger(<span class="hljs-string">&quot;Height&quot;</span>, <span class="hljs-keyword">ref</span> heightOption);
</code></pre>
</div></div><p>Since we are getting a <code>Point3d</code> instance we need to ensure that we have the
<code>Rhino.Geometry</code> namespace available to us.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;first command usings&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-keyword">using</span> Rhino.Geometry;
<span class="hljs-keyword">using</span> System.Collections.Generic;
</code></pre>
</div></div><h5>Initialize the display conduit</h5>
<p>To visualize the user input we need our <code>jesterBoxConduit</code>. We need to
give it all the information it needs to draw properly. First however we need to
initialize an instance that we can use.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;set up jesterBox display conduit&gt;&gt;=</div><div class="code"><pre><code>jesterBoxConduit conduit = <span class="hljs-keyword">new</span> jesterBoxConduit();

conduit.Location = point;
conduit.Width = width;
conduit.Height = height;
conduit.Length = length;

conduit.Enabled = <span class="hljs-literal">true</span>;
</code></pre>
</div></div><h5>Input loop handling</h5>
<p>Now we can start handling the get loop. The loop will be essentially an eternal
loop with proper exit conditions sprinkled throughout the loop.</p>
<p>Each time an option is changed, or a point is clicked we need to update the
conduit as well to ensure proper visualization of the current settings.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;handle get loop&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">for</span>(;;)
{
    GetResult result = getPoint.Get();

    <span class="hljs-keyword">if</span>(result == GetResult.Point)
    {
        point = getPoint.Point();
        conduit.Location = point;
        RhinoApp.WriteLine(<span class="hljs-string">$&quot;User clicked point <span class="hljs-subst">{point}</span>&quot;</span>);
        <span class="hljs-keyword">continue</span>;
    }

    <span class="hljs-keyword">if</span>(result == GetResult.Option)
    {
        width = widthOption.CurrentValue;
        length = lengthOption.CurrentValue;
        height = heightOption.CurrentValue;

        conduit.Width = width;
        conduit.Height = height;
        conduit.Length = length;

        RhinoApp.WriteLine(<span class="hljs-string">$&quot;Current given dimensions <span class="hljs-subst">{width}</span>x<span class="hljs-subst">{length}</span>x<span class="hljs-subst">{height}</span>&quot;</span>);
        <span class="hljs-keyword">continue</span>;
    }

    <span class="hljs-keyword">if</span>(result == GetResult.Nothing)
    {
        <span class="hljs-keyword">break</span>;
    }

    <span class="hljs-keyword">if</span>(result == GetResult.Cancel)
    {
        conduit.Enabled = <span class="hljs-literal">false</span>;
        RhinoApp.WriteLine(<span class="hljs-string">&quot;Command cancelled&quot;</span>);
        <span class="hljs-keyword">return</span> Result.Cancel;
    }
}
</code></pre>
</div></div><h5>Adding the object</h5>
<p>Once we get out of the loop and are still in the command we can add the object
to the specifications given by the user on the command-line. If no point was
specified by the user when we get to this point we are going to use the
<code>PotentialLocation</code> as known by the conduit.</p>
<p>To add the object we use the <code>CreateJesterBox</code> method provided by <code>&lt;&lt;jesterBox command utilities&gt;&gt;</code>.</p>
<p>We also disable our conduit, so it doesn't get called all the time for nothing.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;add the object&gt;&gt;=</div><div class="code"><pre><code>conduit.Enabled = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">if</span>(!point.IsValid) {
    point = conduit.PotentialLocation;
}
Brep boxBrep = CreateJesterBox(point, width, height, length);
doc.Objects.AddBrep(boxBrep);
doc.Views.Redraw();
</code></pre>
</div></div><div class="codefragment"><div class="fragmentname">&lt;&lt;jesterBox command utilities&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> Brep <span class="hljs-title">CreateJesterBox</span>(<span class="hljs-params">Point3d point, <span class="hljs-built_in">int</span> width, <span class="hljs-built_in">int</span> height, <span class="hljs-built_in">int</span> length</span>)</span>
{
    Plane p = <span class="hljs-keyword">new</span> Plane(point, Vector3d.ZAxis);
    Interval widthInterval = <span class="hljs-keyword">new</span> Interval(<span class="hljs-number">0</span>, width);
    Interval lengthInterval = <span class="hljs-keyword">new</span> Interval(<span class="hljs-number">0</span>, length);
    Interval heightInterval = <span class="hljs-keyword">new</span> Interval(<span class="hljs-number">0</span>, height);
    Box box = <span class="hljs-keyword">new</span> Box(p, widthInterval, lengthInterval, heightInterval);
    Brep boxBrep = box.ToBrep();

    <span class="hljs-keyword">if</span>(boxBrep == <span class="hljs-literal">null</span>)
    {
        System.Diagnostics.Debug.WriteLine(<span class="hljs-string">&quot;Our brep is not good :/&quot;</span>);
        System.Diagnostics.Debug.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">{point}</span>, <span class="hljs-subst">{width}</span>x<span class="hljs-subst">{height}</span>x<span class="hljs-subst">{length}</span>&quot;</span>);
        System.Diagnostics.Debug.WriteLine(<span class="hljs-string">$&quot;...&quot;</span>);
    }

    <span class="hljs-keyword">return</span> boxBrep;
}
</code></pre>
</div></div><h2>Creating a DisplayConduit</h2>
<p>To be able to show intermediate results of our command while it is still running
we can use a <code>DisplayConduit</code>. This will allow us to draw results without having
to actually add geometry to the document.</p>
<p>To implement the <code>DisplayConduit</code> we need to inherit
<code>Rhino.Display.DisplayConduit</code>, and at least implement calculation of scene
bounding box and a draw method. For our command and display conduit we are going
to draw in <code>DrawOverlay</code>. We also want to be able to pass on the data to be
visualized, which we'll do with <code>&lt;&lt;jesterBoxConduit data access&gt;&gt;</code>.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;jesterLiveCode source files&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-tag">&lt;<span class="hljs-name">Compile</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">&quot;jesterBoxConduit.cs&quot;</span> /&gt;</span>
</code></pre>
</div></div><div class="codefragment"><div class="fragmentname">&lt;&lt;jesterBox display conduit.*&gt;&gt;=</div><div class="code"><pre><code>&lt;&lt;jesterBox usings&gt;&gt;

<span class="hljs-keyword">namespace</span> <span class="hljs-title">jesterLiveCode</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">jesterBoxConduit</span> : <span class="hljs-title">DisplayConduit</span>
    {
        &lt;&lt;jesterBoxConduit data access&gt;&gt;
        &lt;&lt;jesterBoxConduit calculate bounding box&gt;&gt;
        &lt;&lt;jesterBoxConduit draw overlay&gt;&gt;
    }
}
</code></pre>
</div></div><p>We must not forget to add the proper namespace so we can use it in our class
implementation:</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;jesterBox usings&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">using</span> Rhino.Display;
</code></pre>
</div></div><h3>Data access</h3>
<p>The display conduit implementation will provide several properties to set and
read the information we want to visualize. This will be for the location, width,
height and length of our object.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;jesterBoxConduit data access&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">public</span> Point3d Location { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Width { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Height { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Length { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
</code></pre>
</div></div><p>Not only do we need the dimensions and location of the object to be added, we
<em>also</em> want to know the potential location of the object under the mouse cursor.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;jesterBoxConduit data access&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-keyword">public</span> Point3d PotentialLocation { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
</code></pre>
</div></div><p>Since we need <code>Point3d</code> we also need to bring in the <code>Rhino.Geometry</code> namespace.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;jesterBox usings&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-keyword">using</span> Rhino.Geometry;
</code></pre>
</div></div><h3>Calculating the bounding box</h3>
<p>To be able to properly draw our geometry we need to tell the display pipeline
what the bounding box is for our geometry. Without the proper bounding box
geometry will easily get clipped.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;jesterBoxConduit calculate bounding box&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CalculateBoundingBox</span>(<span class="hljs-params">CalculateBoundingBoxEventArgs bbe</span>)</span>
{
    <span class="hljs-keyword">base</span>.CalculateBoundingBox(bbe);
    Brep box = jesterBoxCommand.CreateJesterBox(Location, Width, Height, Length);
    Brep previewBox = jesterBoxCommand.CreateJesterBox(PotentialLocation, Width, Height, Length);
    BoundingBox bb = box.GetBoundingBox(<span class="hljs-literal">false</span>);
    BoundingBox previewBb = previewBox.GetBoundingBox(<span class="hljs-literal">false</span>);

    bbe.IncludeBoundingBox(bb);
    bbe.IncludeBoundingBox(previewBb);
}
</code></pre>
</div></div><h3>Drawing the temporary geometry</h3>
<div class="codefragment"><div class="fragmentname">&lt;&lt;jesterBoxConduit draw overlay&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawOverlay</span>(<span class="hljs-params">DrawEventArgs drawe</span>)</span>
{
    <span class="hljs-keyword">base</span>.DrawOverlay(drawe);
    <span class="hljs-keyword">if</span>(Location.IsValid)
    {
        Brep box = jesterBoxCommand.CreateJesterBox(Location, Width, Height, Length);
        drawe.Display.DrawBrepWires(box, System.Drawing.Color.Blue);
    }
    Brep previewBox = jesterBoxCommand.CreateJesterBox(PotentialLocation, Width, Height, Length);
    drawe.Display.DrawBrepWires(previewBox, System.Drawing.Color.Gray);
}
</code></pre>
</div></div><h2>Implementing the custom GetPoint class jesterBoxGetPoint</h2>
<p>The custom <code>GetPoint</code> class will be used to communicate mouse location as
<code>Point3d</code> data to the display conduit for drawing a preview of the preview. We
want to show where the new location would end up.</p>
<p>A <code>jesterBoxConduit</code> instance is passed to our <code>GetPoint</code> implementation when it
is constructed. Our class needs to hold on to it, so during <code>OnMouseMove</code> the
conduit can be updated.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;jesterLiveCode source files&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-tag">&lt;<span class="hljs-name">Compile</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">&quot;jesterBoxGetPoint.cs&quot;</span> /&gt;</span>
</code></pre>
</div></div><div class="codefragment"><div class="fragmentname">&lt;&lt;jesterLiveCode jesterBoxGetPoint.*&gt;&gt;=</div><div class="code"><pre><code>&lt;&lt;jesterBoxGetPoint imports&gt;&gt;

<span class="hljs-keyword">namespace</span> <span class="hljs-title">jesterLiveCode</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">jesterBoxGetPoint</span> : <span class="hljs-title">GetPoint</span>
    {
        jesterBoxConduit _conduit;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">jesterBoxGetPoint</span>(<span class="hljs-params">jesterBoxConduit conduit</span>)</span> {
            _conduit = conduit;
        }

        &lt;&lt;jesterBoxGetPoint <span class="hljs-keyword">public</span> API&gt;&gt;
    }
}
</code></pre>
</div></div><p>Since we are inheriting <code>GetPoint</code> we need the <code>Rhino.Input.Custom</code> namespace.
We need also access to <code>Point3d</code> from  the <code>Rhino.Geometry</code> namespace.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;jesterBoxGetPoint imports&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">using</span> Rhino.Input.Custom;
<span class="hljs-keyword">using</span> Rhino.Geometry;
</code></pre>
</div></div><p>There are two parts to the public API for our <code>GetPoint</code> implementation:
overriding the <code>OnMouseMove</code> method and providing a property
<code>PotentialLocation</code>.</p>
<p>Our <code>OnMouseMove</code> implementation is only going to harvest the <code>Point</code> property
from the event argument passed to it when called. This we save to the display
conduit for further usage.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;jesterBoxGetPoint public API&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnMouseMove</span>(<span class="hljs-params">GetPointMouseEventArgs e</span>)</span>
{
    _conduit.PotentialLocation = e.Point;
}
</code></pre>
</div></div><h2>Localizing the command</h2>
<p>Earlier we used <code>Localization.LocalizeString</code> to set up our code for localized versions of the command <code>jesterBox</code>. We need now the localization files that are formatted with XML. The files should be located next to the RHP file our project generates.</p>
<p>For this project lets try to localize some strings to Finnish and Dutch. For now we are going to assume that correct language identifier has been set with Python in a separate script. For Finnish the LCID is 1035 and for Dutch it is 1043.</p>
<h3>Finnish localization</h3>
<div class="codefragment"><div class="fragmentname">&lt;&lt;jesterLiveCode source files&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-tag">&lt;<span class="hljs-name">EmbeddedResource</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">&quot;fi-fijesterLiveCode.xml&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Link</span>&gt;</span>Localization\fi-fijesterLiveCode.xml<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">EmbeddedResource</span>&gt;</span>
</code></pre>
</div></div><div class="codefragment"><div class="fragmentname">&lt;&lt;jesterBox finnish localization.*&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">RMA_LOCALIZATION</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">RMASTRING</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;string&quot;</span> <span class="hljs-attr">English</span>=<span class="hljs-string">&quot;jesterBox[[1]]&quot;</span> <span class="hljs-attr">Localized</span>=<span class="hljs-string">&quot;jesterLaatikko[[1]]&quot;</span> <span class="hljs-attr">file_name</span>=<span class="hljs-string">&quot;jesterBoxCommand.cs&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">RMA_LOCALIZATION</span>&gt;</span>
</code></pre>
</div></div>
	</body>
</html>